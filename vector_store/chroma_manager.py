 
import chromadb
from chromadb.utils import embedding_functions
from chromadb.api import Collection 
from typing import List, Dict, Any, Optional
import logging
import os
import re # For normalization of collection names

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

class ChromaManager:
    """
    Manages interactions with ChromaDB for storing and retrieving document chunks.
    Each repository will typically correspond to a unique ChromaDB collection.
    ChromaDB is configured to handle embeddings internally using a specified model.
    """

    def __init__(self, persist_directory: str = "data/chroma_db", embedding_model_name: str = "all-MiniLM-L6-v2"):
        """
        Initializes the ChromaDB client and configures its embedding function.

        Args:
            persist_directory (str): The local path where ChromaDB will store its data.
            embedding_model_name (str): The name of the SentenceTransformer model for embeddings.
        """
        self.persist_directory = persist_directory
        os.makedirs(self.persist_directory, exist_ok=True)
        self.client = chromadb.PersistentClient(path=self.persist_directory)
        
        # Configure the embedding function for ChromaDB
        self.embedding_function = embedding_functions.SentenceTransformerEmbeddingFunction(
            model_name=embedding_model_name
        )
        logging.info(f"Initialized ChromaDB PersistentClient at: {self.persist_directory} "
                     f"with embedding model: {embedding_model_name}.")

    def get_or_create_collection(self, repo_name: str) -> Collection:
        """
        Gets an existing ChromaDB collection for a repository, or creates a new one if it doesn't exist.
        The embedding function is applied automatically to new collections.

        Args:
            repo_name (str): The unique name of the repository, used as the collection name.

        Returns:
            Collection: The ChromaDB collection object.
        """
        collection_name = self._normalize_collection_name(repo_name)
        
        try:
            # When creating, pass the embedding_function instance
            collection = self.client.get_or_create_collection(
                name=collection_name,
                embedding_function=self.embedding_function # Pass the configured embedding function here
            )
            logging.info(f"Accessed/Created ChromaDB collection: '{collection_name}' for repo '{repo_name}'.")
            return collection
        except Exception as e:
            logging.error(f"Error accessing/creating ChromaDB collection '{collection_name}': {e}", exc_info=True)
            raise RuntimeError(f"Could not get/create ChromaDB collection: {collection_name}") from e

    def add_chunks(self, repo_name: str, chunks: List[Dict]):
        """
        Adds a list of semantically chunked documents to ChromaDB.
        Embeddings are generated automatically by ChromaDB using the configured embedding function.

        Args:
            repo_name (str): The name of the repository (determines the collection).
            chunks (List[Dict]): A list of chunk dictionaries (adhering to CHUNK_SCHEMA).
        """
        if not chunks:
            logging.info(f"No chunks provided for repo '{repo_name}'. Skipping add_chunks.")
            return

        collection = self.get_or_create_collection(repo_name)

        documents = []
        metadatas = []
        ids = []

        for chunk in chunks: # No need to iterate with index if not using external embeddings
            # Ensure each chunk has a unique ID
            unique_id_parts = [
                repo_name,
                chunk['meta']['file_path'],
                str(chunk['meta']['start_line']),
                str(chunk['meta']['end_line']),
            ]
            chunk_id = "_".join(part.replace('/', '_').replace('.', '_') for part in unique_id_parts)
            
            documents.append(chunk['content'])
            metadatas.append(chunk['meta'])
            ids.append(chunk_id)

        try:
            # ChromaDB will automatically embed the documents when you call add/upsert
            collection.upsert(
                documents=documents,
                metadatas=metadatas,
                ids=ids
            )
            logging.info(f"Added/Updated {len(chunks)} chunks to ChromaDB collection '{collection.name}' for repo '{repo_name}'. "
                         f"Embeddings generated by ChromaDB's configured function.")
        except Exception as e:
            logging.error(f"Error adding chunks to ChromaDB collection '{collection.name}': {e}", exc_info=True)
            raise RuntimeError(f"Could not add chunks to ChromaDB: {e}") from e

    def query_collection(self, repo_name: str, query_text: str, top_k: int) -> List[Dict[str, Any]]:
        """
        Queries a ChromaDB collection with a given query text and returns top_k results.
        The query text is embedded by ChromaDB's configured embedding function.

        Args:
            repo_name (str): The name of the repository collection to query.
            query_text (str): The raw text of the user's query.
            top_k (int): The number of top relevant results to retrieve.

        Returns:
            List[Dict]: A list of dictionaries, each containing 'content' and 'meta' of the retrieved chunks.
        """
        collection_name = self._normalize_collection_name(repo_name)
        try:
            collection = self.client.get_collection(name=collection_name) # No embedding_function needed for get_collection
        except Exception: # Collection not found
            logging.warning(f"ChromaDB collection '{collection_name}' not found for repo '{repo_name}'. Cannot query.")
            return []

        try:
            # Pass the raw query text. ChromaDB's embedding function will embed it.
            results = collection.query(
                query_texts=[query_text], # Pass raw text here
                n_results=top_k,
                include=['documents', 'metadatas']
            )
            
            retrieved_chunks = []
            if results and results['documents'] and results['metadatas']:
                for doc, meta in zip(results['documents'][0], results['metadatas'][0]):
                    retrieved_chunks.append({'content': doc, 'meta': meta})
            
            logging.info(f"Queried ChromaDB collection '{collection.name}'. Retrieved {len(retrieved_chunks)} results.")
            return retrieved_chunks

        except Exception as e:
            logging.error(f"Error querying ChromaDB collection '{collection.name}': {e}", exc_info=True)
            raise RuntimeError(f"Could not query ChromaDB: {e}") from e

    def delete_collection(self, repo_name: str):
        collection_name = self._normalize_collection_name(repo_name)
        try:
            self.client.delete_collection(name=collection_name)
            logging.info(f"Deleted ChromaDB collection: '{collection_name}' for repo '{repo_name}'.")
        except Exception as e:
            logging.warning(f"Error deleting ChromaDB collection '{collection_name}': {e}")

    def list_collections(self) -> List[str]:
        try:
            collections = self.client.list_collections()
            return [c.name for c in collections]
        except Exception as e:
            logging.error(f"Error listing ChromaDB collections: {e}", exc_info=True)
            return []

    def _normalize_collection_name(self, name: str) -> str:
        normalized_name = re.sub(r'[^a-zA-Z0-9_.-]', '_', name).lower()
        normalized_name = normalized_name.strip('_.')[:63]
        return normalized_name